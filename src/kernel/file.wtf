#include "io.h"
#include "stdint.h"

#define FDC_DOR    0x3F2  // Digital Output Register
#define FDC_MSR    0x3F4  // Main Status Register
#define FDC_DATA   0x3F5  // Data Register
#define inb i686_inb
#define outb i686_outb

// Wait until controller is ready to accept a byte
static void wait_ready() {
    while (!(inb(FDC_MSR) & 0x80)); // BSY bit clear means ready
}

// Reset and enable floppy controller motor
void floppy_init() {
    outb(FDC_DOR, 0x00); // disable controller
    for (volatile int i = 0; i < 100000; i++); // small delay
    outb(FDC_DOR, 0x0C); // enable controller, motor, drive A
}

// Read a single sector from floppy (512 bytes)
uint8_t floppy_read_sector(uint8_t track, uint8_t head, uint8_t sector, uint8_t *buffer) {
    floppy_init();

    wait_ready();

    // Send READ DATA command
    outb(FDC_DATA, 0x06);           // READ DATA
    outb(FDC_DATA, (head << 2));    // Head & drive (drive A)
    outb(FDC_DATA, track);           // Cylinder
    outb(FDC_DATA, head);            // Head
    outb(FDC_DATA, sector);           // Sector number
    outb(FDC_DATA, 2);               // Bytes/sector = 512
    outb(FDC_DATA, 18);              // Sectors per track (standard 1.44MB)
    outb(FDC_DATA, 0x1B);            // GAP3 length
    outb(FDC_DATA, 0xFF);            // DTL (unused for 512-byte sectors)

    // Read 512 bytes from data register
    for (int i = 0; i < 512; i++) {
        // Wait for data ready
        while (!(inb(FDC_MSR) & 0x80)); // DRQ bit set
        buffer[i] = inb(FDC_DATA);
    }

    // Optional: check status bytes from controller here

    return 0; // success
}

